<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Bee Test</title>
    <style>
        body {
            margin: 0;
            padding: 20px;
            font-family: Arial, sans-serif;
            background: #f0f0f0;
        }
        #container {
            width: 400px;
            height: 400px;
            background: white;
            border: 2px solid #cfaf6a;
            margin: 20px auto;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        #bee-canvas {
            width: 200px;
            height: 200px;
        }
        #logs {
            max-width: 800px;
            margin: 20px auto;
            background: #1e1e1e;
            color: #00ff00;
            padding: 20px;
            font-family: monospace;
            font-size: 12px;
            line-height: 1.5;
            max-height: 500px;
            overflow-y: auto;
        }
        .log-info { color: #00ff00; }
        .log-error { color: #ff0000; }
        .log-warn { color: #ffaa00; }
    </style>
</head>
<body>
    <h1 style="text-align: center;">3D Bee Diagnostic Test</h1>

    <div id="container">
        <canvas id="bee-canvas"></canvas>
    </div>

    <div id="logs"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';

        const logsDiv = document.getElementById('logs');

        function log(message, type = 'info') {
            console.log(message);
            const logEntry = document.createElement('div');
            logEntry.className = `log-${type}`;
            logEntry.textContent = new Date().toLocaleTimeString() + ' - ' + message;
            logsDiv.appendChild(logEntry);
            logsDiv.scrollTop = logsDiv.scrollHeight;
        }

        log('=== 3D BEE DIAGNOSTIC TEST ===', 'info');
        log('Three.js version: ' + THREE.REVISION, 'info');

        const canvas = document.getElementById('bee-canvas');
        const container = document.getElementById('container');

        if (!canvas || !container) {
            log('ERROR: Canvas or container not found!', 'error');
        } else {
            log('Canvas and container found', 'info');
        }

        // Check WebGL support
        const testCanvas = document.createElement('canvas');
        const gl = testCanvas.getContext('webgl') || testCanvas.getContext('experimental-webgl');
        if (!gl) {
            log('ERROR: WebGL not supported in this browser!', 'error');
            container.innerHTML = '<div style="text-align: center;"><h2 style="color: red;">WebGL Not Supported</h2><p>Your browser doesn\'t support WebGL.</p></div>';
        } else {
            log('WebGL is supported ✓', 'info');

            // Set canvas size
            const size = 200;
            const pixelRatio = Math.min(window.devicePixelRatio, 2);
            canvas.width = size * pixelRatio;
            canvas.height = size * pixelRatio;
            canvas.style.width = size + 'px';
            canvas.style.height = size + 'px';

            log(`Canvas size: ${canvas.width}x${canvas.height} (display: ${size}x${size})`, 'info');

            // Create scene
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(45, 1, 0.1, 1000);
            camera.position.set(0, 0, 5);

            // Create renderer
            let renderer;
            try {
                renderer = new THREE.WebGLRenderer({
                    canvas: canvas,
                    alpha: true,
                    antialias: true
                });
                renderer.setSize(size * pixelRatio, size * pixelRatio);
                renderer.setClearColor(0xf0f0f0, 1);
                renderer.setPixelRatio(1);
                renderer.outputColorSpace = THREE.SRGBColorSpace;
                renderer.toneMapping = THREE.ACESFilmicToneMapping;
                renderer.toneMappingExposure = 1.0;
                log('WebGL renderer created successfully ✓', 'info');
            } catch (e) {
                log('ERROR creating WebGL renderer: ' + e.message, 'error');
                throw e;
            }

            // Add lights
            const ambientLight = new THREE.AmbientLight(0xffffff, 2.0);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5);
            directionalLight.position.set(5, 5, 5);
            scene.add(directionalLight);

            log('Lighting added', 'info');

            // Setup DRACO loader
            const dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('https://www.gstatic.com/draco/versioned/decoders/1.5.6/');

            // Load model
            const loader = new GLTFLoader();
            loader.setDRACOLoader(dracoLoader);

            const beePivot = new THREE.Group();
            scene.add(beePivot);

            const glbUrl = new URL('bee-model/scene.gltf', window.location.href).href;
            log('Loading model from: ' + glbUrl, 'info');

            loader.load(
                glbUrl,
                function (gltf) {
                    log('✓ MODEL LOADED SUCCESSFULLY!', 'info');
                    const beeModel = gltf.scene;

                    // Log model info and fix materials
                    let meshCount = 0;
                    beeModel.traverse((child) => {
                        if (child.isMesh) {
                            meshCount++;
                            log(`Mesh ${meshCount}: ${child.name}`, 'info');

                            if (child.material) {
                                const mat = child.material;

                                // Log material details
                                log(`  Material: ${mat.name || 'unnamed'} (${mat.type})`, 'info');
                                log(`  Has map: ${!!mat.map}, color: ${mat.color ? mat.color.getHexString() : 'none'}`, 'info');

                                // Fix material properties
                                mat.side = THREE.DoubleSide;

                                // Since model has no textures, apply bee-like colors based on mesh name
                                if (!mat.map) {
                                    // Wings should be translucent yellowish
                                    if (child.name.includes('wing') || child.name.includes('Wing') ||
                                        meshCount <= 4) { // First few meshes are likely wings
                                        mat.color.setHex(0xd4a76a); // Yellowish/amber
                                        mat.transparent = true;
                                        mat.opacity = 0.6;
                                        mat.roughness = 0.3;
                                        mat.metalness = 0.1;
                                        log(`  Applied wing material (translucent yellow)`, 'warn');
                                    }
                                    // Body parts should be brown/black
                                    else {
                                        mat.color.setHex(0x3d2817); // Dark brown
                                        mat.roughness = 0.7;
                                        mat.metalness = 0.2;
                                        log(`  Applied body material (dark brown)`, 'warn');
                                    }
                                } else {
                                    // If textures exist, ensure proper color space
                                    mat.map.colorSpace = THREE.SRGBColorSpace;
                                    mat.map.needsUpdate = true;
                                    log(`  Applied sRGB color space to base texture`, 'info');
                                }

                                // Fix other texture maps
                                ['normalMap', 'roughnessMap', 'metalnessMap', 'aoMap', 'emissiveMap'].forEach(mapName => {
                                    if (mat[mapName]) {
                                        mat[mapName].needsUpdate = true;
                                    }
                                });

                                // Ensure material updates
                                mat.needsUpdate = true;
                            }
                        }
                    });
                    log(`Model contains ${meshCount} meshes`, 'info');

                    // Center and scale
                    const box = new THREE.Box3().setFromObject(beeModel);
                    const center = box.getCenter(new THREE.Vector3());
                    const modelSize = box.getSize(new THREE.Vector3());

                    log(`Model dimensions: ${modelSize.x.toFixed(2)} x ${modelSize.y.toFixed(2)} x ${modelSize.z.toFixed(2)}`, 'info');

                    const maxDim = Math.max(modelSize.x, modelSize.y, modelSize.z);
                    const scale = maxDim > 0.001 ? 1.8 / maxDim : 1;

                    log(`Applied scale: ${scale.toFixed(3)}`, 'info');

                    beeModel.scale.set(scale, scale, scale);
                    beeModel.position.set(
                        -center.x * scale,
                        -center.y * scale,
                        -center.z * scale
                    );

                    beePivot.add(beeModel);
                    beePivot.rotation.y = Math.PI / 4;

                    log('✓ Model added to scene and ready!', 'info');
                },
                function (xhr) {
                    if (xhr.lengthComputable) {
                        const percentComplete = (xhr.loaded / xhr.total) * 100;
                        log(`Loading progress: ${Math.round(percentComplete)}%`, 'info');
                    }
                },
                function (error) {
                    log('ERROR loading model: ' + error.message, 'error');
                    log('Full error: ' + JSON.stringify(error), 'error');
                }
            );

            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                beePivot.rotation.y += 0.01;
                renderer.render(scene, camera);
            }

            animate();
            log('Animation loop started', 'info');
        }
    </script>
</body>
</html>
